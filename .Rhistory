arrays <- create_arrays(data)
T <- arrays$T
R <- arrays$R
if (is.null(lambda))
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
if (is.null(gamma))
gamma <- array(rep(1 / R, R))
standata <- list(K = arrays$K,
R = arrays$R,
T = arrays$T,
S = arrays$S,
predict_sample_mat = arrays$prediction_array,
y = arrays$true_value_array,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = dirichlet_alpha)
# model <- stanmodels$stacking_crps     # use inside package
model <- rstan::stan_model("stan/crps_test.stan")
opt <- rstan::optimizing(model, data = standata)
return(opt$par)
}
stack_crps(stackr::example_prepared_data)
stack_crps(stackr::sample_prepared_data)
stack_crps <- function(data,
lambda = NULL,
gamma = NULL,
dirichlet_alpha = 1.001) {
arrays <- create_arrays(data)
T <- arrays$T
R <- arrays$R
if (is.null(lambda))
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
if (is.null(gamma))
gamma <- array(rep(1 / R, R))
standata <- list(K = arrays$K,
R = arrays$R,
T = arrays$T,
S = arrays$S,
predict_sample_mat = arrays$prediction_array,
y = arrays$true_value_array,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = dirichlet_alpha)
model <- stanmodels$stacking_crps     # use inside package
# model <- rstan::stan_model("stan/crps_test.stan")
opt <- rstan::optimizing(model, data = standata)
return(opt$par)
}
stack_crps(stackr::sample_prepared_data)
document()
library(stackr)
library(stackr)
document()
?use_mit_license()
use_mit_license("Nikos Bosse")
install.packages("tibble")
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
library(rstan)
seed = 1
model <- rstan::stan_model("stan/crps_test.stan")
K = 5 # number of models
R = 1 # number of regions
T = 100 # number of timesteps
S = 200 # number of predictive samples
## time point weights
lambda <- numeric(T)
for (t in 1:T) {
# lambda[t] = 1.5 - (1 - (t + 0.0) /T)^2;
lambda[t] = 1; # try equal weights for now
}
## region weights
gamma <- array(0, R)
for (r in 1:R) {
gamma[r] <- 1.0 / R;
}
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1))
}
}
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1))
}
}
K = 2# number of models
R = 1 # number of regions
T = 100 # number of timesteps
S = 200 # number of predictive samples
## time point weights
lambda <- numeric(T)
for (t in 1:T) {
# lambda[t] = 1.5 - (1 - (t + 0.0) /T)^2;
lambda[t] = 1; # try equal weights for now
}
## region weights
gamma <- array(0, R)
for (r in 1:R) {
gamma[r] <- 1.0 / R;
}
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1))
}
}
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
y_mat <- array(yval, c(R, T))
y_mat <- array(y_val, c(R, T))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = predict_sample_mat,
y = y_mat,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = 1.01
)
opt <- rstan::optimizing(model, data = standata,seed=20)
library(stackr)
model <- stackr:::stanmodels$stacking_crps
opt <- rstan::optimizing(model, data = standata,seed=20)
opt
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
y_mat <- array(y_val, c(R, T))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = predict_sample_mat,
y = y_mat,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = 1.01
)
model <- stackr:::stanmodels$stacking_crps
opt <- rstan::optimizing(model, data = standata,seed=20)
opt
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
y_mat <- array(y_val, c(R, T))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = predict_sample_mat,
y = y_mat,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = 1.01
)
model <- stackr:::stanmodels$stacking_crps
opt <- rstan::optimizing(model, data = standata,seed=20)
opt
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1))
}
}
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
y_mat <- array(y_val, c(R, T))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = predict_sample_mat,
y = y_mat,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = 1.01
)
model <- stackr:::stanmodels$stacking_crps
opt <- rstan::optimizing(model, data = standata,seed=20)
opt
K = 3# number of models
## time point weights
lambda <- numeric(T)
for (t in 1:T) {
# lambda[t] = 1.5 - (1 - (t + 0.0) /T)^2;
lambda[t] = 1; # try equal weights for now
}
## region weights
gamma <- array(0, R)
for (r in 1:R) {
gamma[r] <- 1.0 / R;
}
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1))
}
}
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5),
rnorm(S * R, mean = 0.5)),
size = S * R)
y_mat <- array(y_val, c(R, T))
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1),
rnorm(S, mean = 0.5))
}
}
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
y_mat <- array(y_val, c(R, T))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = predict_sample_mat,
y = y_mat,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = 1.01
)
model <- stackr:::stanmodels$stacking_crps
opt <- rstan::optimizing(model, data = standata,seed=20)
opt
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1),
rnorm(S, mean = 3))
}
}
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
# create an example array
predict_sample_mat <- array(NA, c(T, R, S,K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_mat[t, r, , ] <- cbind(rnorm(S, 2, 1),
rnorm(S, 0.5, 1),
rnorm(S, mean = 4))
}
}
# create observed true values
y_val <- sample(c(rnorm(S * R, mean = 2),
rnorm(S * R, mean = 0.5)),
size = S * R)
y_mat <- array(y_val, c(R, T))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = predict_sample_mat,
y = y_mat,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = 1.01
)
model <- stackr:::stanmodels$stacking_crps
opt <- rstan::optimizing(model, data = standata,seed=20)
opt
data <- stackr::sample_prepared_data
data
weights <- stackr::stack_crps(data)
library(stackr)
weights <- stackr::stack_crps(data)
library(tidyverse)
weights <- stackr::stack_crps(data)
weights
data
# number of models
models <- data$model %>%
unique()
K <- length(models)
regions <- data$geography %>%
unique()
R <- length(regions)
S <- data$sample_nr %>% max()
dates <- data$date %>%
unique()
T <- length(dates)
S
data
tibble(geography = regions)
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1])
mix
timepoint = "2020-03-14"
data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% timepoint)
models
regions
timepoint
data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint))
?sample
S
length(weights)
w <- rep(weights, each = S) / (S * length(weights))
w
draw_from_models <- function(data,
models,
weights,
regions,
S,
timepoint) {
vec <- data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint)) %>%
.$y_pred
w <- rep(weights, each = S) / (S * length(weights))
return(sample(vec, replace = T, prob = w))
}
draw_from_models <- function(data,
models,
weights,
regions,
S,
timepoint) {
vec <- data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint)) %>%
.$y_pred
w <- rep(weights, each = S) / (S * length(weights))
return(sample(vec, size = S, replace = T, prob = w))
}
data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date)
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))) %>%
dplyr::ungroup()
mix
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::rename(model = "Mixture")
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture")
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture") %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))) %>%
dplyr::ungroup()
mix
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture") %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))) %>%
dplyr::ungroup()
mix
create_sampled_mixture <- function(data,
type = "crps",
weights = NULL) {
# number of models
models <- data$model %>%
unique()
K <- length(models)
regions <- data$geography %>%
unique()
R <- length(regions)
S <- data$sample_nr %>% max()
dates <- data$date %>%
unique()
T <- length(dates)
draw_from_models <- function(data,
models,
weights,
regions,
S,
timepoint) {
vec <- data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint)) %>%
.$y_pred
w <- rep(weights, each = S) / (S * length(weights))
return(sample(vec, size = S, replace = T, prob = w))
}
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture") %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))) %>%
dplyr::ungroup()
return(mix)
}
create_sampled_mixture <- function(data,
weights = NULL,
type = "crps") {
# number of models
models <- data$model %>%
unique()
K <- length(models)
regions <- data$geography %>%
unique()
R <- length(regions)
S <- data$sample_nr %>% max()
dates <- data$date %>%
unique()
T <- length(dates)
draw_from_models <- function(data,
models,
weights,
regions,
S,
timepoint) {
vec <- data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint)) %>%
.$y_pred
w <- rep(weights, each = S) / (S * length(weights))
return(sample(vec, size = S, replace = T, prob = w))
}
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture") %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))) %>%
dplyr::ungroup()
return(mix)
}
data <- stackr::sample_prepared_data
weights <- stackr::stack_crps(data)
create_sampled_mixture(data, weights = weights)
library(stackr)
document()
library(devtools)
document()
library(stackr)
