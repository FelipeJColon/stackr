data %>%
dplyr::filter(sample_nr %in% 1:2) %>%
split(by = c("sample_nr", "model", "geography")) %>%
abind::abind(along = c(3)) %>%
dim
data %>%
dplyr::filter(sample_nr %in% 1:2)
data %>%
dplyr::filter(sample_nr %in% 1:2) %>%
split(by = c("sample_nr", "model", "geography")) %>%
abind::abind(along = c(3)) %>%
dim
data %>%
dplyr::filter(sample_nr %in% 1:2) %>%
split(by = c("sample_nr", "model", "geography"))
class(data)
data %>%
dplyr::filter(sample_nr %in% 1:2) %>% class()
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
abind::abind(along = c(3)) %>%
dim
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography"))
predict_sample_arr <- array(NA, c(T, R, S, K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_arr[t, r, , ] <- data %>%
dplyr::filter(date == dates[t], geography == regions[r]) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred) %>%
dplyr::select(all_of(models)) %>%
as.matrix()
}
}
data
data %>%
dplyr::filter(date == dates[t], geography == regions[r]) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred)
t
r
r = 1
data %>%
dplyr::filter(date == dates[t], geography == regions[r]) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred)
# number of regions
regions <- unique(data$geography)
R <- length(regions)
predict_sample_arr <- array(NA, c(T, R, S, K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_arr[t, r, , ] <- data %>%
dplyr::filter(date == dates[t], geography == regions[r]) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred) %>%
dplyr::select(all_of(models)) %>%
as.matrix()
}
}
predict_sample_arr
predict_sample_arr_ref <- predict_sample_arr
data
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
abind::abind(along = c(3)) %>%
dim
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
abind::abind(along = c(3))
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography"))
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>% length()
S * K
S * K * R
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K))
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>% length()
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>%
simplify2array(abind::abind(along = 3))
data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>%
lapply(abind::abind(along = 3))
l <- data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K))
l
l[[1]]
l[[1]] %>%
abind::abind(along = 3)
l <- data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>%
lapply(abind::abind()
l[[1]] %>%
abind::abind(along = 3)
length()
abind::abind(along = c(3))
2 * K * R
split(d, ceiling(seq_along(d)/20))
array(1:12, c(1, 2, 3, 2))
ar == predict_sample_arr_ref
dim(predict_sample_arr_ref)
[, ..models]
?abind::abind
?simplify2array()
# create an array that holds all the predictions
predict_sample_arr <- array(NA, c(T, R, S, K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_arr[t, r, , ] <- data %>%
dplyr::filter(date == dates[t], geography == regions[r]) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred) %>%
dplyr::select(all_of(models)) %>%
as.matrix()
}
}
y_arr <- array(NA, c(R, T))
for (r in 1:R) {
y_arr[r, ] <- data %>%
dplyr::filter(geography %in% regions[r],
sample_nr == 1,
model == models[1]) %>%
.$y_obs # %>% unique()
}
return(list(prediction_array = predict_sample_arr,
true_value_array = y_arr,
K = K,
R = R,
T = T,
S = S))
}
l <- data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>%
lapply(abind::abind())
l[[1]] %>%
abind::abind()
l[[1]] %>%
unlist()
l[[1]] %>%
unlist() %>%
abind::abind()
l[[1]] %>%
abind::abind()
abind::abind(rev.along = c(3))
abind::abind(rev.along = c(2))
l[[1]] %>%
abind::abind(rev.along = 3)
l[[1]] %>%
abind::abind(rev.along = 2)
l[[1]] %>%
abind::abind(rev.along = 4)
l[[1]] %>%
abind::abind(rev.along = 0)
l <- data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>%
lapply(abind::abind(rev.along = 0))
l[[2]] %>%
abind::abind(rev.along = 0)
l <- data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K))
l[[2]] %>%
abind::abind(rev.along = 0)
l <- data[sample_nr %in% 1:2, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>%
apply(abind::abind(rev.along = 0))
lapply(l, FUN = abind::abind(rev.along = 0))
a <- l[[1]] %>%
abind::abind(rev.along = 0)
b <- l[[1]] %>%
abind::abind(rev.along = 0)
abind(a, b)
abind::abind(list(a, b))
abind::abind(list(a, b)) %>% dim()
abind::abind(list(a, b), rev.along = 0) %>% dim()
abind::abind(list(a, b), rev.along = 0)
l <- data[sample_nr %in% 1:3, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 2 * K)) %>%
lapply(abind::abind(rev.along = 0))
l <- data[sample_nr %in% 1:3, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 3 * K)) %>%
lapply(abind::abind(rev.along = 0))
l <- data[sample_nr %in% 1:3, ] %>%
split(by = c("sample_nr", "model", "geography")) %>%
split(rep(1:R, each = 3 * K))
l
a <- l[[1]] %>%
abind::abind(rev.along = 0)
b <- l[[1]] %>%
abind::abind(rev.along = 0)
a <- l[[1]] %>%
abind::abind(rev.along = 0)
b <- l[[2]] %>%
abind::abind(rev.along = 0)
c <- l[[3]] %>%
abind::abind(rev.along = 0)
l
abind::abind(list(a, b), rev.along = 0) %>% dim()
dim(predict_sample_arr_ref)
l <- data[sample_nr %in% 1:3, ] %>%
split(by = c("sample_nr", "model", "geography"))
l
split(data[sample_nr %in% 1:3, ], by = list(data$sample_nr, data$model, data$geography))
split(data[sample_nr %in% 1:3, ], list(data$sample_nr, data$model, data$geography))
data[order(sample_nr, model, geography)]
data[order(sample_nr, model, geography)]$y_pred
z <- data[order(sample_nr, model, geography)]$y_pred %>%
array(c(T, R, S, K))
z
z == predict_sample_arr_ref
z
dim(z)
dim(predict_sample_arr_ref)
predict_sample_arr_ref
z
z <- data[order(sample_nr, geography, model)]$y_pred %>%
array(c(T, R, S, K))
dim(z)
dim(predict_sample_arr_ref)
z == predict_sample_arr_ref
z <- data[order(model, sample_nr, geography)]$y_pred %>%
array(c(T, R, S, K))
dim(z)
dim(predict_sample_arr_ref)
z == predict_sample_arr_ref
pred_array <- array(data[order(model, sample_nr, geography)]$y_pred,
dim = c(T, R, S, K))
pred_array
pred_array == predict_sample_arr_ref
all(pred_array == predict_sample_arr_ref)
dplyr::arrange(data, model, sample_nr, geography)$y_pred
p2 <- array(dplyr::arrange(data, model, sample_nr, geography)$y_pred,
dim = c/T, R, S, K)
p2 <- array(dplyr::arrange(data, model, sample_nr, geography)$y_pred,
dim = c(T, R, S, K))
ps == pred_array
p2 == pred_array
all(p2 == pred_array)
# turn data.frame into arrays for further processing
arrays <- stackr::create_arrays(data)
library(tidyverse)
# turn data.frame into arrays for further processing
arrays <- stackr::create_arrays(data)
data
# turn data.frame into arrays for further processing
arrays <- stackr::create_arrays(testdata)
# turn predictions into array that can be passed to the stan model
pred_array <- array(dplyr::arrange(testdata, model, sample_nr, geography)$y_pred,
dim = c(T, R, S, K))
arrays
arrays$prediction_array == pred_array
arrays$prediction_array
arrays$prediction_array %>% dim()
R
R = 1
# turn predictions into array that can be passed to the stan model
pred_array <- array(dplyr::arrange(testdata, model, sample_nr, geography)$y_pred,
dim = c(T, R, S, K))
arrays$prediction_array == pred_array
all(arrays$prediction_array == pred_array)
data <- testdata
# number of models
models <- unique(data$model)
K <- length(models)
# number of regions
regions <- unique(data$geography)
R <- length(regions)
# number of predictive samples
S <- max(data$sample_nr)
# get number of timepoints
dates <- unique(data$date)
T <- length(dates)
predict_sample_arr <- array(NA, c(T, R, S, K))
for (r in 1:R) {
for (t in 1:T) {
predict_sample_arr[t, r, , ] <- data %>%
dplyr::filter(date == dates[t], geography == regions[r]) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred) %>%
dplyr::select(all_of(models)) %>%
as.matrix()
}
}
y_arr <- array(NA, c(R, T))
for (r in 1:R) {
y_arr[r, ] <- data %>%
dplyr::filter(geography %in% regions[r],
sample_nr == 1,
model == models[1]) %>%
.$y_obs # %>% unique()
}
y_arr
testdata
data <- rbind(data,
data %>%
dplyr::mutate(geography = "Zimbabwe"))
y_arr <- array(NA, c(R, T))
R = 2
y_arr <- array(NA, c(R, T))
regions
regions <- data$geography %>% unique()
y_arr <- array(NA, c(R, T))
for (r in 1:R) {
y_arr[r, ] <- data %>%
dplyr::filter(geography %in% regions[r],
sample_nr == 1,
model == models[1]) %>%
.$y_obs # %>% unique()
}
y_arr
data <- rbind(testdata,
testdata %>%
mutate(geography = "Zimbabwe",
y_obs = 2 * y_obs))
y_arr <- array(NA, c(R, T))
for (r in 1:R) {
y_arr[r, ] <- data %>%
dplyr::filter(geography %in% regions[r],
sample_nr == 1,
model == models[1]) %>%
.$y_obs # %>% unique()
}
y_arr
data
data %>%
dplyr::filter(sample_nr == 1,
model == models[1])
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(geography)
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(geography) %>%
dplyr::pull(y_pred)
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(geography) %>%
dplyr::pull(y_pred) %>%
array(c(R, T))
y_arr
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(geography) %>%
dplyr::pull(y_obs) %>%
array(c(R, T))
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(geography)
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(geography, date) %>%
dplyr::pull(y_obs) %>%
array(c(R, T))
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(geography, date) %>%
dplyr::pull(y_obs)
y_arr
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(date, geography) %>%
dplyr::pull(y_obs) %>%
array(c(R, T))
y_arr
data %>%
dplyr::filter(sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(date, geography) %>%
dplyr::pull(y_obs) %>%
array(c(R, T)) == y_arr
crps_weights <- function(data,
lambda = NULL,
gamma = NULL,
dirichlet_alpha = 1.001) {
# check if geography exists. if not, create a region
if (!("geography" %in% names(data)))
data$geography <- "Atlantis"
# number of models
models <- unique(data$model)
K <- length(models)
# number of regions
regions <- unique(data$geography)
R <- length(regions)
# number of predictive samples
S <- max(data$sample_nr)
# get number of timepoints
dates <- unique(data$date)
T <- length(dates)
# turn predictions into array that can be passed to the stan model
pred_array <- array(dplyr::arrange(testdata, model, sample_nr, geography)$y_pred,
dim = c(T, R, S, K))
# turn observations into array that can be passed to the stan model
y_array <- dplyr::filter(data,
sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(date, geography) %>%
dplyr::pull(y_obs) %>%
array(c(R, T))
# assign quadratic or equal weights if no numeric lambda given
if (is.null(lambda)) {
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
} else if (lambda == "equal") {
lambda <- rep(1/T, T)
}
if (is.null(gamma))
gamma <- array(rep(1 / R, R))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = pred_array,
y = y_array
lambda = lambda,
gamma = gamma,
dirichlet_alpha = dirichlet_alpha)
model <- stanmodels$stacking_crps     # use inside package
# model <- rstan::stan_model("stan/crps_test.stan")
opt <- rstan::optimizing(model, data = standata)
return(opt$par)
}
crps_weights <- function(data,
lambda = NULL,
gamma = NULL,
dirichlet_alpha = 1.001) {
# check if geography exists. if not, create a region
if (!("geography" %in% names(data)))
data$geography <- "Atlantis"
# number of models
models <- unique(data$model)
K <- length(models)
# number of regions
regions <- unique(data$geography)
R <- length(regions)
# number of predictive samples
S <- max(data$sample_nr)
# get number of timepoints
dates <- unique(data$date)
T <- length(dates)
# turn predictions into array that can be passed to the stan model
pred_array <- array(dplyr::arrange(testdata, model, sample_nr, geography)$y_pred,
dim = c(T, R, S, K))
# turn observations into array that can be passed to the stan model
y_array <- dplyr::filter(data,
sample_nr == 1,
model == models[1]) %>%
dplyr::arrange(date, geography) %>%
dplyr::pull(y_obs) %>%
array(c(R, T))
# assign quadratic or equal weights if no numeric lambda given
if (is.null(lambda)) {
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
} else if (lambda == "equal") {
lambda <- rep(1/T, T)
}
if (is.null(gamma))
gamma <- array(rep(1 / R, R))
standata <- list(K = K,
R = R,
T = T,
S = S,
predict_sample_mat = pred_array,
y = y_array,
lambda = lambda,
gamma = gamma,
dirichlet_alpha = dirichlet_alpha)
model <- stanmodels$stacking_crps     # use inside package
# model <- rstan::stan_model("stan/crps_test.stan")
opt <- rstan::optimizing(model, data = standata)
return(opt$par)
}
weights <- crps_weights(traindata)
library(stackr)
weights <- crps_weights(traindata)
stanmodels <- stackr:::stanmodels
weights <- crps_weights(traindata)
weights
weights <- crps_weights(traindata)
weights
splitdate <- as.Date("2020-04-01")
traindata <- stackr::sample_prepared_data %>%
dplyr::filter(date <= splitdate)
testdata <- stackr::sample_prepared_data %>%
dplyr::filter(date > splitdate)
weights <- crps_weights(traindata)
test_mixture <- mixture_from_sample(testdata,
weights = weights)
rbind(testdata,
test_mixture) %>%
group_by(model, forecast_date) %>%
dplyr::mutate(crps = scoringutils::crps(unique(y_obs),
t(as.vector(y_pred)))) %>%
group_by(model) %>%
dplyr::summarise(crps = mean(crps))
