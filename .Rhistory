i <- 1
while(remainder > 0) {
ints[order[i]] <- ints[order[i]] + 1
remainder <- remainder - 1
}
return(ints)
}
integer_part <- round_with_preserved_sum(S*weights)
integer_part_index <- c(0,cumsum(integer_part))
existing_draws <- integer_part_index[K+1]
if (existing_draws < S){
remaining_draws <- S - existing_draws
remaining_assignment <- sample(1:K,
remaining_draws,
prob = weight,
replace = F)
integer_part[remaining_assignment] <- integer_part[remaining_assignment] + 1
}
mixture_vector <- rep(NA, S)
for(k in 1:K) {
mixture_vector[(1 + integer_part_index[k]):integer_part_index[k + 1]] <-
individual_draws[1:integer_part[k], k]
}
return(mixture_vector)
}
data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture") %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date)))
draw_from_models <-  function(data,
models,
weights,
regions,
S,
timepoint,
permutation = TRUE)
{
# S <- nrow(data)
K <- length(models)
individual_draws <- data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint)) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred,
names_prefix = "y_pred_") %>%
dplyr::select(starts_with("y_pred_")) %>%
as.matrix()
if (permutation == TRUE) {
individual_draws <- individual_draws[sample(1:S), ]	 # random permutation of draws
}
round_with_preserved_sum <- function(x) {
target_sum = sum(x)
ints <- as.integer(x)
int_sum <- sum(ints)
remainder <- target_sum - int_sum
decimals <- x - ints
order <- order(decimals, decreasing = T)
i <- 1
while(remainder > 0) {
ints[order[i]] <- ints[order[i]] + 1
remainder <- remainder - 1
}
return(ints)
}
integer_part <- round_with_preserved_sum(S*weights)
integer_part_index <- c(0,cumsum(integer_part))
existing_draws <- integer_part_index[K+1]
if (existing_draws < S){
remaining_draws <- S - existing_draws
remaining_assignment <- sample(1:K,
remaining_draws,
prob = weights,
replace = F)
integer_part[remaining_assignment] <- integer_part[remaining_assignment] + 1
}
mixture_vector <- rep(NA, S)
for(k in 1:K) {
mixture_vector[(1 + integer_part_index[k]):integer_part_index[k + 1]] <-
individual_draws[1:integer_part[k], k]
}
return(mixture_vector)
}
data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture") %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))) %>%
dplyr::ungroup()
draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date)))
draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))
draw_from_models(data,
models,
weights,
regions,
S,
timepoint)
draw_from_models(data,
models,
weights,
regions,
S,
timepoint) %>% length
S
# S <- nrow(data)
K <- length(models)
individual_draws <- data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint)) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred,
names_prefix = "y_pred_") %>%
dplyr::select(starts_with("y_pred_")) %>%
as.matrix()
if (permutation == TRUE) {
individual_draws <- individual_draws[sample(1:S), ]	 # random permutation of draws
}
round_with_preserved_sum <- function(x) {
target_sum = sum(x)
ints <- as.integer(x)
int_sum <- sum(ints)
remainder <- target_sum - int_sum
decimals <- x - ints
order <- order(decimals, decreasing = T)
i <- 1
while(remainder > 0) {
ints[order[i]] <- ints[order[i]] + 1
remainder <- remainder - 1
}
return(ints)
}
integer_part <- round_with_preserved_sum(S*weights)
integer_part
integer_part_index <- c(0,cumsum(integer_part))
integer_part_index
existing_draws <- integer_part_index[K+1]
existing_draws
if (existing_draws < S){
remaining_draws <- S - existing_draws
remaining_assignment <- sample(1:K,
remaining_draws,
prob = weights,
replace = F)
integer_part[remaining_assignment] <- integer_part[remaining_assignment] + 1
}
existing_draws
mixture_vector <- rep(NA, S)
for(k in 1:K) {
mixture_vector[(1 + integer_part_index[k]):integer_part_index[k + 1]] <-
individual_draws[1:integer_part[k], k]
}
mixture_vector
mixture_vector %>% length()
mixture_vector <- rep(NA, S)
k = 1
(1 + integer_part_index[k]):integer_part_index[k + 1]
(1 + integer_part_index[k]):integer_part_index[k + 1]
mixture_vector[(1 + integer_part_index[k]):integer_part_index[k + 1]]
integer_part_index
integer_part
mixture_vector <- rep(NA, S)
for(k in 1:K) {
if (integer_part[k] = 0) next()
mixture_vector[(1 + integer_part_index[k]):integer_part_index[k + 1]] <-
individual_draws[1:integer_part[k], k]
}
for(k in 1:K) {
if (integer_part[k] == 0)
next()
mixture_vector[(1 + integer_part_index[k]):integer_part_index[k + 1]] <-
individual_draws[1:integer_part[k], k]
}
mixture_vector %>% length()
mixture_from_sample <- function(data,
weights = NULL,
type = "crps") {
# number of models
models <- data$model %>%
unique()
K <- length(models)
regions <- data$geography %>%
unique()
R <- length(regions)
S <- data$sample_nr %>% max()
dates <- data$date %>%
unique()
T <- length(dates)
draw_from_models <-  function(data,
models,
weights,
regions,
S,
timepoint,
permutation = TRUE)
{
# S <- nrow(data)
K <- length(models)
individual_draws <- data %>%
dplyr::filter(model %in% models,
geography %in% regions,
date %in% as.Date(timepoint)) %>%
tidyr::pivot_wider(names_from = model, values_from = y_pred,
names_prefix = "y_pred_") %>%
dplyr::select(starts_with("y_pred_")) %>%
as.matrix()
if (permutation == TRUE) {
individual_draws <- individual_draws[sample(1:S), ]	 # random permutation of draws
}
round_with_preserved_sum <- function(x) {
target_sum = sum(x)
ints <- as.integer(x)
int_sum <- sum(ints)
remainder <- target_sum - int_sum
decimals <- x - ints
order <- order(decimals, decreasing = T)
i <- 1
while(remainder > 0) {
ints[order[i]] <- ints[order[i]] + 1
remainder <- remainder - 1
}
return(ints)
}
integer_part <- round_with_preserved_sum(S*weights)
integer_part_index <- c(0,cumsum(integer_part))
existing_draws <- integer_part_index[K+1]
if (existing_draws < S){
remaining_draws <- S - existing_draws
remaining_assignment <- sample(1:K,
remaining_draws,
prob = weights,
replace = F)
integer_part[remaining_assignment] <- integer_part[remaining_assignment] + 1
}
mixture_vector <- rep(NA, S)
for(k in 1:K) {
# skip if no draws to make
if (integer_part[k] == 0)
next()
mixture_vector[(1 + integer_part_index[k]):integer_part_index[k + 1]] <-
individual_draws[1:integer_part[k], k]
}
return(mixture_vector)
}
# copy one model and fill data.frame
mix <- data %>%
dplyr::filter(model == models[1]) %>%
dplyr::group_by(geography, date) %>%
dplyr::mutate(model = "Mixture") %>%
dplyr::mutate(y_pred = draw_from_models(data,
models,
weights,
unique(geography),
S,
unique(date))) %>%
dplyr::ungroup()
return(mix)
}
test_mixture <- mixture_from_sample(testdata,
weights = weights)
devtools::document()
ints
y_true <- rnorm(100)
y_pred <- replicate(20, rnorm(100))
y_pred
t <- 100
n <- 50
y_true <- rnorm(t)
y_pred <- replicate(t, rnorm(n))
y_pred
library(rstan)
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
m
standata <- list(y = y_true,
T = t,
S = n,
predict_sample_mat = y_pred,
dirchlet_alpha = 1.001,
lambda = rep(1, t))
res <- rstan::optimizing(m, standata)
standata <- list(y = y_true,
T = t,
S = n,
predict_sample_mat = y_pred,
dirichlet_alpha = 1.001,
lambda = rep(1, t))
res <- rstan::optimizing(m, standata)
res
dim(y_pred)
S = n <- 50
T = t <- 100
colMeans(y_pred)
mean(y_true - colMeans(y_pred))
res <- rstan::sampling(m, standata)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
res
res
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
standata <- list(y = y_true,
T = t,
S = n,
predict_sample_mat = y_pred,
dirichlet_alpha = 1.001,
lambda = rep(1, t))
res <- rstan::sampling(m, standata)
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
standata <- list(y = y_true,
T = t,
S = n,
predict_sample_mat = y_pred,
dirichlet_alpha = 1.001,
lambda = rep(1, t))
res <- rstan::sampling(m, standata)
res
res2 <- rstan::optimizing(m, standata)
res2
mean(y_true - colMeans(y_pred))
scoringutils::crps(y, y_pred)
scoringutils::crps(y_true, y_pred)
scoringutils::crps(y_true, t(y_pred))
mean(scoringutils::crps(y_true, t(y_pred)))
res2
b1 <- res2$par
b1
b2 <- mean(y_true - colMeans(y_pred))
b2
mean(scoringutils::crps(y_true, t(y_pred - b1)))
mean(scoringutils::crps(y_true, t(y_pred - b2)))
mean(scoringutils::crps(y_true, t(y_pred)))
res
y_true <- rnorm(t)
y_pred <- replicate(t, rnorm(n, mean = 1.4))
standata <- list(y = y_true,
T = t,
S = n,
predict_sample_mat = y_pred,
dirichlet_alpha = 1.001,
lambda = rep(1, t))
#res <- rstan::sampling(m, standata)
res2 <- rstan::optimizing(m, standata)
res2
b1 <- res2$par
b1
b2 <- mean(y_true - colMeans(y_pred))
b2
mean(scoringutils::crps(y_true, t(y_pred)))
mean(scoringutils::crps(y_true, t(y_pred - b1)))
mean(scoringutils::crps(y_true, t(y_pred - b2)))
mean(scoringutils::crps(y_true, t(y_pred + b1)))
mean(scoringutils::crps(y_true, t(y_pred + b2)))
y_pred <- replicate(t, rnorm(n, mean = 0))
standata <- list(y = y_true,
T = t,
S = n,
predict_sample_mat = y_pred,
dirichlet_alpha = 1.001,
lambda = rep(1, t))
#res <- rstan::sampling(m, standata)
res2 <- rstan::optimizing(m, standata)
b1 <- res2$par
b2 <- mean(y_true - colMeans(y_pred))
mean(scoringutils::crps(y_true, t(y_pred)))
mean(scoringutils::crps(y_true, t(y_pred + b1)))
mean(scoringutils::crps(y_true, t(y_pred + b2)))
m <- rstan::stan_model("inst/stan/bias_adjustment.stan")
library(devtools)
devtools::document()
devtools::document()
library(stackr)
S <- 50
T <- 100
y_true <- rnorm(T)
y_pred <- replicate(T, rnorm(S, mean = 1))
bias_adjustment(y_true, y_pred)
bias_adjustment <- function(y_true,
y_pred,
lambda) {
T <- length(y_true)
S <- nrow(y_pred)
model <- stanmodels$bias_adjustment
if (is.null(lambda))
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
standata <- list(y = y_true,
T = T,
S = S,
predict_sample_mat = y_pred,
# dirichlet_alpha = 1.001,
lambda = rep(1, t))
model <- stanmodels$stacking_crps     # use inside package
correction_term <- rstan::optimizing(model, data = standata)
}
S <- 50
T <- 100
y_true <- rnorm(T)
y_pred <- replicate(T, rnorm(S, mean = 1))
bias_adjustment(y_true, y_pred)
bias_adjustment <- function(y_true,
y_pred,
lambda = NULL) {
T <- length(y_true)
S <- nrow(y_pred)
model <- stanmodels$bias_adjustment
if (is.null(lambda))
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
standata <- list(y = y_true,
T = T,
S = S,
predict_sample_mat = y_pred,
# dirichlet_alpha = 1.001,
lambda = rep(1, t))
model <- stanmodels$stacking_crps     # use inside package
correction_term <- rstan::optimizing(model, data = standata)
}
S <- 50
T <- 100
y_true <- rnorm(T)
y_pred <- replicate(T, rnorm(S, mean = 1))
bias_adjustment(y_true, y_pred)
bias_adjustment <- function(y_true,
y_pred,
lambda = NULL) {
T <- length(y_true)
S <- nrow(y_pred)
model <- stanmodels$bias_adjustment
if (is.null(lambda))
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
standata <- list(y = y_true,
T = T,
S = S,
predict_sample_mat = y_pred,
# dirichlet_alpha = 1.001,
lambda = rep(1, t))
model <- stanmodels$bias_adjustment     # use inside package
correction_term <- rstan::optimizing(model, data = standata)
}
S <- 50
T <- 100
y_true <- rnorm(T)
y_pred <- replicate(T, rnorm(S, mean = 1))
bias_adjustment(y_true, y_pred)
bias_adjustment(y_true, y_pred)
bias_adjustment <- function(y_true,
y_pred,
lambda = NULL) {
T <- length(y_true)
S <- nrow(y_pred)
model <- stanmodels$bias_adjustment
if (is.null(lambda))
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
standata <- list(y = y_true,
T = T,
S = S,
predict_sample_mat = y_pred,
# dirichlet_alpha = 1.001,
lambda = rep(1, t))
model <- stanmodels$bias_adjustment     # use inside package
correction_term <- rstan::optimizing(model, data = standata)
return(correction_term)
}
bias_adjustment(y_true, y_pred)
bias_adjustment <- function(y_true,
y_pred,
lambda = NULL) {
T <- length(y_true)
S <- nrow(y_pred)
model <- stanmodels$bias_adjustment
if (is.null(lambda))
for (t in 1:T)
lambda[t] <- 2 - (1 - t / T)^2
standata <- list(y = y_true,
T = T,
S = S,
predict_sample_mat = y_pred,
# dirichlet_alpha = 1.001,
lambda = rep(1, t))
model <- stanmodels$bias_adjustment     # use inside package
correction_term <- rstan::optimizing(model, data = standata)
return(correction_term$par)
}
bias_adjustment(y_true, y_pred)
bias_adjustment(y_true, y_pred)
bias_adjustment(y_true, y_pred)
